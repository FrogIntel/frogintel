.class public final Lkotlinx/coroutines/test/TestCoroutineScopeKt;
.super Ljava/lang/Object;
.source "TestCoroutineScope.kt"


# annotations
.annotation system Ldalvik/annotation/SourceDebugExtension;
    value = "SMAP\nTestCoroutineScope.kt\nKotlin\n*S Kotlin\n*F\n+ 1 TestCoroutineScope.kt\nkotlinx/coroutines/test/TestCoroutineScopeKt\n*L\n1#1,346:1\n217#1,2:347\n217#1,2:349\n217#1,2:351\n217#1,2:353\n217#1,2:355\n*S KotlinDebug\n*F\n+ 1 TestCoroutineScope.kt\nkotlinx/coroutines/test/TestCoroutineScopeKt\n*L\n228#1:347,2\n245#1:349,2\n262#1:351,2\n273#1:353,2\n344#1:355,2\n*E\n"
.end annotation

.annotation runtime Lkotlin/Metadata;
    d1 = {
        "\u0000H\n\u0000\n\u0002\u0010\t\n\u0002\u0018\u0002\n\u0002\u0008\u0005\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0008\u0006\n\u0002\u0010 \n\u0002\u0010\u0003\n\u0002\u0008\u0007\n\u0002\u0010\"\n\u0002\u0018\u0002\n\u0000\n\u0002\u0010\u0002\n\u0002\u0008\u0004\n\u0002\u0018\u0002\n\u0002\u0018\u0002\n\u0002\u0010\u0000\n\u0002\u0008\u0004\u001a\u0012\u0010\u0015\u001a\u00020\u00022\u0008\u0008\u0002\u0010\u0016\u001a\u00020\tH\u0007\u001a\u0012\u0010\u0017\u001a\u00020\u00022\u0008\u0008\u0002\u0010\u0016\u001a\u00020\tH\u0007\u001a\u0012\u0010\u0018\u001a\u0008\u0012\u0004\u0012\u00020\u001a0\u0019*\u00020\tH\u0000\u001a\u0014\u0010\u001b\u001a\u00020\u001c*\u00020\u00022\u0006\u0010\u001d\u001a\u00020\u0001H\u0007\u001a\u000c\u0010\u001e\u001a\u00020\u001c*\u00020\u0002H\u0007\u001a\u000c\u0010\u001f\u001a\u00020\u001c*\u00020\u0002H\u0007\u001a3\u0010\u001f\u001a\u00020\u001c*\u00020\u00022\u001c\u0010 \u001a\u0018\u0008\u0001\u0012\n\u0012\u0008\u0012\u0004\u0012\u00020\u001c0\"\u0012\u0006\u0012\u0004\u0018\u00010#0!H\u0087@\u00f8\u0001\u0000\u00a2\u0006\u0002\u0010$\u001a\u000c\u0010%\u001a\u00020\u001c*\u00020\u0002H\u0007\u001a\u000c\u0010&\u001a\u00020\u001c*\u00020\u0002H\u0007\"\u001e\u0010\u0000\u001a\u00020\u0001*\u00020\u00028FX\u0087\u0004\u00a2\u0006\u000c\u0012\u0004\u0008\u0003\u0010\u0004\u001a\u0004\u0008\u0005\u0010\u0006\"\u001b\u0010\u0007\u001a\u0004\u0018\u00010\u0008*\u00020\t8\u00c2\u0002X\u0082\u0004\u00a2\u0006\u0006\u001a\u0004\u0008\n\u0010\u000b\"\u0018\u0010\u000c\u001a\u00020\u0008*\u00020\u00028BX\u0082\u0004\u00a2\u0006\u0006\u001a\u0004\u0008\r\u0010\u000e\"$\u0010\u000f\u001a\u0008\u0012\u0004\u0012\u00020\u00110\u0010*\u00020\u00028FX\u0087\u0004\u00a2\u0006\u000c\u0012\u0004\u0008\u0012\u0010\u0004\u001a\u0004\u0008\u0013\u0010\u0014\u0082\u0002\u0004\n\u0002\u0008\u0019\u00a8\u0006\'"
    }
    d2 = {
        "currentTime",
        "",
        "Lkotlinx/coroutines/test/TestCoroutineScope;",
        "getCurrentTime$annotations",
        "(Lkotlinx/coroutines/test/TestCoroutineScope;)V",
        "getCurrentTime",
        "(Lkotlinx/coroutines/test/TestCoroutineScope;)J",
        "delayController",
        "Lkotlinx/coroutines/test/DelayController;",
        "Lkotlin/coroutines/CoroutineContext;",
        "getDelayController",
        "(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/DelayController;",
        "delayControllerForPausing",
        "getDelayControllerForPausing",
        "(Lkotlinx/coroutines/test/TestCoroutineScope;)Lkotlinx/coroutines/test/DelayController;",
        "uncaughtExceptions",
        "",
        "",
        "getUncaughtExceptions$annotations",
        "getUncaughtExceptions",
        "(Lkotlinx/coroutines/test/TestCoroutineScope;)Ljava/util/List;",
        "TestCoroutineScope",
        "context",
        "createTestCoroutineScope",
        "activeJobs",
        "",
        "Lkotlinx/coroutines/Job;",
        "advanceTimeBy",
        "",
        "delayTimeMillis",
        "advanceUntilIdle",
        "pauseDispatcher",
        "block",
        "Lkotlin/Function1;",
        "Lkotlin/coroutines/Continuation;",
        "",
        "(Lkotlinx/coroutines/test/TestCoroutineScope;Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;",
        "resumeDispatcher",
        "runCurrent",
        "kotlinx-coroutines-test"
    }
    k = 0x2
    mv = {
        0x1,
        0x6,
        0x0
    }
    xi = 0x30
.end annotation


# direct methods
.method public static final TestCoroutineScope(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/TestCoroutineScope;
    .registers 3
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "This constructs a `TestCoroutineScope` with a deprecated `CoroutineDispatcher` by default. Please use `createTestCoroutineScope` instead."
        replaceWith = .subannotation Lkotlin/ReplaceWith;
            expression = "createTestCoroutineScope(TestCoroutineDispatcher() + TestCoroutineExceptionHandler() + context)"
            imports = {
                "kotlin.coroutines.EmptyCoroutineContext"
            }
        .end subannotation
    .end annotation

    .line 143
    sget-object v0, Lkotlinx/coroutines/test/TestCoroutineScheduler;->Key:Lkotlinx/coroutines/test/TestCoroutineScheduler$Key;

    check-cast v0, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v0}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v0

    check-cast v0, Lkotlinx/coroutines/test/TestCoroutineScheduler;

    if-nez v0, :cond_0

    new-instance v0, Lkotlinx/coroutines/test/TestCoroutineScheduler;

    invoke-direct {v0}, Lkotlinx/coroutines/test/TestCoroutineScheduler;-><init>()V

    .line 144
    :cond_0
    new-instance v1, Lkotlinx/coroutines/test/TestCoroutineDispatcher;

    invoke-direct {v1, v0}, Lkotlinx/coroutines/test/TestCoroutineDispatcher;-><init>(Lkotlinx/coroutines/test/TestCoroutineScheduler;)V

    new-instance v0, Lkotlinx/coroutines/test/TestCoroutineExceptionHandler;

    invoke-direct {v0}, Lkotlinx/coroutines/test/TestCoroutineExceptionHandler;-><init>()V

    check-cast v0, Lkotlin/coroutines/CoroutineContext;

    invoke-virtual {v1, v0}, Lkotlinx/coroutines/test/TestCoroutineDispatcher;->plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;

    move-result-object v0

    invoke-interface {v0, p0}, Lkotlin/coroutines/CoroutineContext;->plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->createTestCoroutineScope(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/TestCoroutineScope;

    move-result-object p0

    return-object p0
.end method

.method public static synthetic TestCoroutineScope$default(Lkotlin/coroutines/CoroutineContext;ILjava/lang/Object;)Lkotlinx/coroutines/test/TestCoroutineScope;
    .registers 3

    and-int/lit8 p1, p1, 0x1

    if-eqz p1, :cond_0

    .line 142
    sget-object p0, Lkotlin/coroutines/EmptyCoroutineContext;->INSTANCE:Lkotlin/coroutines/EmptyCoroutineContext;

    check-cast p0, Lkotlin/coroutines/CoroutineContext;

    :cond_0
    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->TestCoroutineScope(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/TestCoroutineScope;

    move-result-object p0

    return-object p0
.end method

.method public static final activeJobs(Lkotlin/coroutines/CoroutineContext;)Ljava/util/Set;
    .registers 2
    .annotation system Ldalvik/annotation/Signature;
        value = {
            "(",
            "Lkotlin/coroutines/CoroutineContext;",
            ")",
            "Ljava/util/Set<",
            "Lkotlinx/coroutines/Job;",
            ">;"
        }
    .end annotation

    .line 124
    sget-object v0, Lkotlinx/coroutines/Job;->Key:Lkotlinx/coroutines/Job$Key;

    check-cast v0, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v0}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object p0

    if-eqz p0, :cond_0

    check-cast p0, Lkotlinx/coroutines/Job;

    invoke-interface {p0}, Lkotlinx/coroutines/Job;->getChildren()Lkotlin/sequences/Sequence;

    move-result-object p0

    sget-object v0, Lkotlinx/coroutines/test/TestCoroutineScopeKt$activeJobs$1;->INSTANCE:Lkotlinx/coroutines/test/TestCoroutineScopeKt$activeJobs$1;

    check-cast v0, Lkotlin/jvm/functions/Function1;

    invoke-static {p0, v0}, Lkotlin/sequences/SequencesKt;->filter(Lkotlin/sequences/Sequence;Lkotlin/jvm/functions/Function1;)Lkotlin/sequences/Sequence;

    move-result-object p0

    invoke-static {p0}, Lkotlin/sequences/SequencesKt;->toSet(Lkotlin/sequences/Sequence;)Ljava/util/Set;

    move-result-object p0

    return-object p0

    :cond_0
    new-instance p0, Ljava/lang/IllegalStateException;

    const-string v0, "Required value was null."

    invoke-virtual {v0}, Ljava/lang/Object;->toString()Ljava/lang/String;

    move-result-object v0

    invoke-direct {p0, v0}, Ljava/lang/IllegalStateException;-><init>(Ljava/lang/String;)V

    throw p0
.end method

.method public static final advanceTimeBy(Lkotlinx/coroutines/test/TestCoroutineScope;J)V
    .registers 5
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "The name of this function is misleading: it not only advances the time, but also runs the tasks scheduled *at* the ending moment."
        replaceWith = .subannotation Lkotlin/ReplaceWith;
            expression = "this.testScheduler.apply { advanceTimeBy(delayTimeMillis); runCurrent() }"
            imports = {}
        .end subannotation
    .end annotation

    .line 245
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object v0

    .line 349
    sget-object v1, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v1, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {v0, v1}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v0

    check-cast v0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 350
    instance-of v1, v0, Lkotlinx/coroutines/test/DelayController;

    if-eqz v1, :cond_0

    check-cast v0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    const/4 v0, 0x0

    :goto_0
    if-nez v0, :cond_1

    .line 247
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getTestScheduler()Lkotlinx/coroutines/test/TestCoroutineScheduler;

    move-result-object v0

    invoke-virtual {v0, p1, p2}, Lkotlinx/coroutines/test/TestCoroutineScheduler;->advanceTimeBy(J)V

    .line 248
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getTestScheduler()Lkotlinx/coroutines/test/TestCoroutineScheduler;

    move-result-object p0

    invoke-virtual {p0}, Lkotlinx/coroutines/test/TestCoroutineScheduler;->runCurrent()V

    goto :goto_1

    .line 251
    :cond_1
    invoke-interface {v0, p1, p2}, Lkotlinx/coroutines/test/DelayController;->advanceTimeBy(J)J

    :goto_1
    return-void
.end method

.method public static final advanceUntilIdle(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 3

    .line 262
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object v0

    .line 351
    sget-object v1, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v1, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {v0, v1}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v0

    check-cast v0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 352
    instance-of v1, v0, Lkotlinx/coroutines/test/DelayController;

    if-eqz v1, :cond_0

    check-cast v0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    const/4 v0, 0x0

    :goto_0
    if-eqz v0, :cond_1

    .line 262
    invoke-interface {v0}, Lkotlinx/coroutines/test/DelayController;->advanceUntilIdle()J

    goto :goto_1

    :cond_1
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getTestScheduler()Lkotlinx/coroutines/test/TestCoroutineScheduler;

    move-result-object p0

    invoke-virtual {p0}, Lkotlinx/coroutines/test/TestCoroutineScheduler;->advanceUntilIdle()V

    :goto_1
    return-void
.end method

.method public static final createTestCoroutineScope(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/TestCoroutineScope;
    .registers 5
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "This function was introduced in order to help migrate from TestCoroutineScope to TestScope. Please use TestScope() construction instead, or just runTest(), without creating a scope."
    .end annotation

    .line 185
    invoke-static {p0}, Lkotlinx/coroutines/test/TestScopeKt;->withDelaySkipping(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    .line 186
    new-instance v0, Lkotlin/jvm/internal/Ref$ObjectRef;

    invoke-direct {v0}, Lkotlin/jvm/internal/Ref$ObjectRef;-><init>()V

    .line 188
    sget-object v1, Lkotlinx/coroutines/CoroutineExceptionHandler;->Key:Lkotlinx/coroutines/CoroutineExceptionHandler$Key;

    new-instance v2, Lkotlinx/coroutines/test/TestCoroutineScopeKt$createTestCoroutineScope$ownExceptionHandler$1;

    invoke-direct {v2, v0, v1}, Lkotlinx/coroutines/test/TestCoroutineScopeKt$createTestCoroutineScope$ownExceptionHandler$1;-><init>(Lkotlin/jvm/internal/Ref$ObjectRef;Lkotlinx/coroutines/CoroutineExceptionHandler$Key;)V

    .line 194
    sget-object v1, Lkotlinx/coroutines/CoroutineExceptionHandler;->Key:Lkotlinx/coroutines/CoroutineExceptionHandler$Key;

    check-cast v1, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v1}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v1

    check-cast v1, Lkotlinx/coroutines/CoroutineExceptionHandler;

    .line 195
    instance-of v3, v1, Lkotlinx/coroutines/test/UncaughtExceptionCaptor;

    if-eqz v3, :cond_0

    goto :goto_0

    :cond_0
    if-nez v1, :cond_1

    .line 196
    move-object v1, v2

    check-cast v1, Lkotlinx/coroutines/CoroutineExceptionHandler;

    goto :goto_0

    .line 197
    :cond_1
    instance-of v1, v1, Lkotlinx/coroutines/test/TestCoroutineScopeExceptionHandler;

    if-eqz v1, :cond_3

    move-object v1, v2

    check-cast v1, Lkotlinx/coroutines/CoroutineExceptionHandler;

    .line 204
    :goto_0
    sget-object v2, Lkotlinx/coroutines/Job;->Key:Lkotlinx/coroutines/Job$Key;

    check-cast v2, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v2}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v2

    check-cast v2, Lkotlinx/coroutines/Job;

    if-nez v2, :cond_2

    const/4 v2, 0x1

    const/4 v3, 0x0

    invoke-static {v3, v2, v3}, Lkotlinx/coroutines/JobKt;->Job$default(Lkotlinx/coroutines/Job;ILjava/lang/Object;)Lkotlinx/coroutines/CompletableJob;

    move-result-object v2

    check-cast v2, Lkotlinx/coroutines/Job;

    .line 205
    :cond_2
    new-instance v3, Lkotlinx/coroutines/test/TestCoroutineScopeImpl;

    check-cast v1, Lkotlin/coroutines/CoroutineContext;

    invoke-interface {p0, v1}, Lkotlin/coroutines/CoroutineContext;->plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    check-cast v2, Lkotlin/coroutines/CoroutineContext;

    invoke-interface {p0, v2}, Lkotlin/coroutines/CoroutineContext;->plus(Lkotlin/coroutines/CoroutineContext;)Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    invoke-direct {v3, p0}, Lkotlinx/coroutines/test/TestCoroutineScopeImpl;-><init>(Lkotlin/coroutines/CoroutineContext;)V

    .line 206
    iput-object v3, v0, Lkotlin/jvm/internal/Ref$ObjectRef;->element:Ljava/lang/Object;

    .line 205
    check-cast v3, Lkotlinx/coroutines/test/TestCoroutineScope;

    return-object v3

    .line 198
    :cond_3
    new-instance p0, Ljava/lang/IllegalArgumentException;

    const-string v0, "A CoroutineExceptionHandler was passed to TestCoroutineScope. Please pass it as an argument to a `launch` or `async` block on an already-created scope if uncaught exceptions require special treatment."

    invoke-direct {p0, v0}, Ljava/lang/IllegalArgumentException;-><init>(Ljava/lang/String;)V

    throw p0
.end method

.method public static synthetic createTestCoroutineScope$default(Lkotlin/coroutines/CoroutineContext;ILjava/lang/Object;)Lkotlinx/coroutines/test/TestCoroutineScope;
    .registers 3

    and-int/lit8 p1, p1, 0x1

    if-eqz p1, :cond_0

    .line 184
    sget-object p0, Lkotlin/coroutines/EmptyCoroutineContext;->INSTANCE:Lkotlin/coroutines/EmptyCoroutineContext;

    check-cast p0, Lkotlin/coroutines/CoroutineContext;

    :cond_0
    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->createTestCoroutineScope(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/TestCoroutineScope;

    move-result-object p0

    return-object p0
.end method

.method public static final getCurrentTime(Lkotlinx/coroutines/test/TestCoroutineScope;)J
    .registers 3

    .line 228
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object v0

    .line 347
    sget-object v1, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v1, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {v0, v1}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v0

    check-cast v0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 348
    instance-of v1, v0, Lkotlinx/coroutines/test/DelayController;

    if-eqz v1, :cond_0

    check-cast v0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    const/4 v0, 0x0

    :goto_0
    if-eqz v0, :cond_1

    .line 228
    invoke-interface {v0}, Lkotlinx/coroutines/test/DelayController;->getCurrentTime()J

    move-result-wide v0

    goto :goto_1

    :cond_1
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getTestScheduler()Lkotlinx/coroutines/test/TestCoroutineScheduler;

    move-result-object p0

    invoke-virtual {p0}, Lkotlinx/coroutines/test/TestCoroutineScheduler;->getCurrentTime()J

    move-result-wide v0

    :goto_1
    return-wide v0
.end method

.method public static synthetic getCurrentTime$annotations(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 1

    return-void
.end method

.method private static final getDelayController(Lkotlin/coroutines/CoroutineContext;)Lkotlinx/coroutines/test/DelayController;
    .registers 2

    .line 217
    sget-object v0, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v0, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v0}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object p0

    check-cast p0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 218
    instance-of v0, p0, Lkotlinx/coroutines/test/DelayController;

    if-eqz v0, :cond_0

    check-cast p0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    const/4 p0, 0x0

    :goto_0
    return-object p0
.end method

.method private static final getDelayControllerForPausing(Lkotlinx/coroutines/test/TestCoroutineScope;)Lkotlinx/coroutines/test/DelayController;
    .registers 2

    .line 344
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    .line 355
    sget-object v0, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v0, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v0}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object p0

    check-cast p0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 356
    instance-of v0, p0, Lkotlinx/coroutines/test/DelayController;

    if-eqz v0, :cond_0

    check-cast p0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    const/4 p0, 0x0

    :goto_0
    if-eqz p0, :cond_1

    return-object p0

    .line 345
    :cond_1
    new-instance p0, Ljava/lang/IllegalStateException;

    const-string v0, "This scope isn\'t able to pause its dispatchers"

    invoke-direct {p0, v0}, Ljava/lang/IllegalStateException;-><init>(Ljava/lang/String;)V

    throw p0
.end method

.method public static final getUncaughtExceptions(Lkotlinx/coroutines/test/TestCoroutineScope;)Ljava/util/List;
    .registers 2
    .annotation system Ldalvik/annotation/Signature;
        value = {
            "(",
            "Lkotlinx/coroutines/test/TestCoroutineScope;",
            ")",
            "Ljava/util/List<",
            "Ljava/lang/Throwable;",
            ">;"
        }
    .end annotation

    .line 340
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object p0

    sget-object v0, Lkotlinx/coroutines/CoroutineExceptionHandler;->Key:Lkotlinx/coroutines/CoroutineExceptionHandler$Key;

    check-cast v0, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {p0, v0}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object p0

    instance-of v0, p0, Lkotlinx/coroutines/test/UncaughtExceptionCaptor;

    if-eqz v0, :cond_0

    check-cast p0, Lkotlinx/coroutines/test/UncaughtExceptionCaptor;

    goto :goto_0

    :cond_0
    const/4 p0, 0x0

    :goto_0
    if-eqz p0, :cond_1

    invoke-interface {p0}, Lkotlinx/coroutines/test/UncaughtExceptionCaptor;->getUncaughtExceptions()Ljava/util/List;

    move-result-object p0

    if-nez p0, :cond_2

    .line 341
    :cond_1
    invoke-static {}, Lkotlin/collections/CollectionsKt;->emptyList()Ljava/util/List;

    move-result-object p0

    :cond_2
    return-object p0
.end method

.method public static synthetic getUncaughtExceptions$annotations(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 1
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "This list is only populated if `UncaughtExceptionCaptor` is in the test context, and so can be easily misused. It is only present for backward compatibility and will be removed in the subsequent releases. If you need to check the list of exceptions, please consider creating your own `CoroutineExceptionHandler`."
    .end annotation

    return-void
.end method

.method public static final pauseDispatcher(Lkotlinx/coroutines/test/TestCoroutineScope;Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;
    .registers 3
    .annotation system Ldalvik/annotation/Signature;
        value = {
            "(",
            "Lkotlinx/coroutines/test/TestCoroutineScope;",
            "Lkotlin/jvm/functions/Function1<",
            "-",
            "Lkotlin/coroutines/Continuation<",
            "-",
            "Lkotlin/Unit;",
            ">;+",
            "Ljava/lang/Object;",
            ">;",
            "Lkotlin/coroutines/Continuation<",
            "-",
            "Lkotlin/Unit;",
            ">;)",
            "Ljava/lang/Object;"
        }
    .end annotation

    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "The test coroutine scope isn\'t able to pause its dispatchers in the general case. Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \"paused\", like `StandardTestDispatcher`."
        replaceWith = .subannotation Lkotlin/ReplaceWith;
            expression = "(this.coroutineContext[ContinuationInterceptor]!! as DelayController).pauseDispatcher(block)"
            imports = {
                "kotlin.coroutines.ContinuationInterceptor"
            }
        .end subannotation
    .end annotation

    .line 289
    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->getDelayControllerForPausing(Lkotlinx/coroutines/test/TestCoroutineScope;)Lkotlinx/coroutines/test/DelayController;

    move-result-object p0

    invoke-interface {p0, p1, p2}, Lkotlinx/coroutines/test/DelayController;->pauseDispatcher(Lkotlin/jvm/functions/Function1;Lkotlin/coroutines/Continuation;)Ljava/lang/Object;

    move-result-object p0

    invoke-static {}, Lkotlin/coroutines/intrinsics/IntrinsicsKt;->getCOROUTINE_SUSPENDED()Ljava/lang/Object;

    move-result-object p1

    if-ne p0, p1, :cond_0

    return-object p0

    :cond_0
    sget-object p0, Lkotlin/Unit;->INSTANCE:Lkotlin/Unit;

    return-object p0
.end method

.method public static final pauseDispatcher(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 1
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "The test coroutine scope isn\'t able to pause its dispatchers in the general case. Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \"paused\", like `StandardTestDispatcher`."
        replaceWith = .subannotation Lkotlin/ReplaceWith;
            expression = "(this.coroutineContext[ContinuationInterceptor]!! as DelayController).pauseDispatcher()"
            imports = {
                "kotlin.coroutines.ContinuationInterceptor"
            }
        .end subannotation
    .end annotation

    .line 305
    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->getDelayControllerForPausing(Lkotlinx/coroutines/test/TestCoroutineScope;)Lkotlinx/coroutines/test/DelayController;

    move-result-object p0

    invoke-interface {p0}, Lkotlinx/coroutines/test/DelayController;->pauseDispatcher()V

    return-void
.end method

.method public static final resumeDispatcher(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 1
    .annotation runtime Lkotlin/Deprecated;
        level = .enum Lkotlin/DeprecationLevel;->WARNING:Lkotlin/DeprecationLevel;
        message = "The test coroutine scope isn\'t able to pause its dispatchers in the general case. Only `TestCoroutineDispatcher` supports pausing; pause it directly, or use a dispatcher that is always \"paused\", like `StandardTestDispatcher`."
        replaceWith = .subannotation Lkotlin/ReplaceWith;
            expression = "(this.coroutineContext[ContinuationInterceptor]!! as DelayController).resumeDispatcher()"
            imports = {
                "kotlin.coroutines.ContinuationInterceptor"
            }
        .end subannotation
    .end annotation

    .line 321
    invoke-static {p0}, Lkotlinx/coroutines/test/TestCoroutineScopeKt;->getDelayControllerForPausing(Lkotlinx/coroutines/test/TestCoroutineScope;)Lkotlinx/coroutines/test/DelayController;

    move-result-object p0

    invoke-interface {p0}, Lkotlinx/coroutines/test/DelayController;->resumeDispatcher()V

    return-void
.end method

.method public static final runCurrent(Lkotlinx/coroutines/test/TestCoroutineScope;)V
    .registers 4

    .line 273
    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getCoroutineContext()Lkotlin/coroutines/CoroutineContext;

    move-result-object v0

    .line 353
    sget-object v1, Lkotlin/coroutines/ContinuationInterceptor;->Key:Lkotlin/coroutines/ContinuationInterceptor$Key;

    check-cast v1, Lkotlin/coroutines/CoroutineContext$Key;

    invoke-interface {v0, v1}, Lkotlin/coroutines/CoroutineContext;->get(Lkotlin/coroutines/CoroutineContext$Key;)Lkotlin/coroutines/CoroutineContext$Element;

    move-result-object v0

    check-cast v0, Lkotlin/coroutines/ContinuationInterceptor;

    .line 354
    instance-of v1, v0, Lkotlinx/coroutines/test/DelayController;

    const/4 v2, 0x0

    if-eqz v1, :cond_0

    check-cast v0, Lkotlinx/coroutines/test/DelayController;

    goto :goto_0

    :cond_0
    move-object v0, v2

    :goto_0
    if-eqz v0, :cond_1

    .line 273
    invoke-interface {v0}, Lkotlinx/coroutines/test/DelayController;->runCurrent()V

    sget-object v2, Lkotlin/Unit;->INSTANCE:Lkotlin/Unit;

    :cond_1
    if-nez v2, :cond_2

    invoke-interface {p0}, Lkotlinx/coroutines/test/TestCoroutineScope;->getTestScheduler()Lkotlinx/coroutines/test/TestCoroutineScheduler;

    move-result-object p0

    invoke-virtual {p0}, Lkotlinx/coroutines/test/TestCoroutineScheduler;->runCurrent()V

    :cond_2
    return-void
.end method
